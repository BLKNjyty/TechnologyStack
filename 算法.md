## 算法：

### 状态机

#### 	题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。

	详细描述：
	数值（按顺序）可以分成以下几个部分：
	1.若干空格
	2.一个 小数 或者 整数
	3.（可选）一个 'e' 或 'E' ，后面跟着一个 整数
	4.若干空格
	
	小数（按顺序）可以分成以下几个部分：
	1.（可选）一个符号字符（'+' 或 '-'）
	2.下述格式之一：
	至少一位数字，后面跟着一个点 '.'
	至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
	一个点 '.' ，后面跟着至少一位数字
	
	整数（按顺序）可以分成以下几个部分：
	1.（可选）一个符号字符（'+' 或 '-'）
	2.至少一位数字
	部分数值列举如下：
	
	["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"]
	部分非数值列举如下：
	
	["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"]
	
	来源：力扣（LeetCode）
	链接：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof

#### 思考(避坑)：

按照一个顺序，有许多if判断的情况，可以用状态机

很容易根据从左到右划分状态：

![状态图1](images\状态图1.png)

代码：

```java
class Solution {
    public boolean isNumber(String s) {
        
       Map[] states={
        new HashMap<>(){{put('k',0);put('d',2);put('c',3);put('s',1);}},//0
        new HashMap<>(){{put('d',2);put('c',3);}},//1
        new HashMap<>(){{put('d',2);put('k',8);put('e',5);put('c',3);}},//2
        new HashMap<>(){{put('d',4);put('k',8);}},//3
        new HashMap<>(){{put('d',4);put('k',8);put('e',5);}},//4
        new HashMap<>(){{put('s',6);put('d',7);}},//5
        new HashMap<>(){{put('d',7);}},//6
        new HashMap<>(){{put('k',8);put('d',7);}},//7
        new HashMap<>(){{put('k',8);}}//8
       };
       int p=0;
       char t;
       for(char c:s.toCharArray()){
           if(c >= '0' && c <= '9') t = 'd';
            else if(c == '+' || c == '-') t = 's';
            else if(c == 'e' || c == 'E') t = 'e';
            else if(c == '.') t = 'c';
            else if(c==' ')t='k';
            else t = '?';
            if(!states[p].containsKey(t)) return false;
            p = (int)states[p].get(t);
       }
       return p==2||p==4||p==7||p==8;
    }
    

}
```

**但是这样的列举状态有一个漏洞，3状态，"-."时应返回false；"3."时应返回true。**

**所以需要吧3状态拆分，小数点前有整数，小数点前无整数。两种。**

可以死记一下：小数点的情况，分为   **.后数字**  和 **.前为空的时候.后的数字**

[参考大佬做法](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/)

#### 列举状态：

按照字符串从左到右的顺序，定义以下 9 种状态。 

0开始的空格
1幂符号前的正负号
2小数点前的数字
3小数点、小数点后的数字
4当小数点前为空格时，小数点、小数点后的数字
5幂符号
6幂符号后的正负号
7幂符号后的数字
8结尾的空格

所以合法的状态：为2,3,7,8

#### 状态转移图：

![1622636301](images\1622636301.jpg)

#### 代码：

```java
class Solution {
    public boolean isNumber(String s) {
        Map[] states = {
         new HashMap<>() {{ put(' ', 0); put('s', 1); put('d', 2); put('.', 4); }}, // 0.
         new HashMap<>() {{ put('d', 2); put('.', 4); }},                           // 1.
         new HashMap<>() {{ put('d', 2); put('.', 3); put('e', 5); put(' ', 8); }}, // 2.
         new HashMap<>() {{ put('d', 3); put('e', 5); put(' ', 8); }},              // 3.
         new HashMap<>() {{ put('d', 3); }},                                        // 4.
         new HashMap<>() {{ put('s', 6); put('d', 7); }},                           // 5.
         new HashMap<>() {{ put('d', 7); }},                                        // 6.
         new HashMap<>() {{ put('d', 7); put(' ', 8); }},                           // 7.
         new HashMap<>() {{ put(' ', 8); }}                                         // 8.
        };
        int p = 0;
        char t;
        for(char c : s.toCharArray()) {
            if(c >= '0' && c <= '9') t = 'd';
            else if(c == '+' || c == '-') t = 's';
            else if(c == 'e' || c == 'E') t = 'e';
            else if(c == '.' || c == ' ') t = c;
            else t = '?';
            if(!states[p].containsKey(t)) return false;
            p = (int)states[p].get(t);
        }
        return p == 2 || p == 3 || p == 7 || p == 8;
    }
}


```

### 单调栈

#### 1.

##### 定义全新栈的数据结构，使其能在O(1)的复杂度内获得栈的最小元素

实例：

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

##### 思考：

可以用原始栈和另外的数据结构来存储元素：

1.栈+列表：每次取最小需要遍历列表list，时间复杂度是O(n)，不满足要求

2.栈+单调栈：一个栈正常存放元素，另外一个栈栈顶只存放比前面都小的元素，每次取最小时，直接从第二个栈的栈顶取就可以。复杂度O(1)，满足要求

##### 代码：

```java
class MinStack{
    Stack<Integer> stack1,stack2;
    public MinStack(){
        stack1=new Stack<>();
        stack2=new Stack<>();
    }
    public void push(int x){
        stack1.push(x);
        //必须是<=
        if(stack2.isEmpty()||stack2.peek()>=x){
            stack2.push(x);
        }
    }
    public void pop(){
        if(stack1.pop().equals(stack2.peek())){
            stack2.pop();
        }
    }
    public int top(){
        return stack1.peek();
    }
    public int min(){
        return stack2.peek();
    }
    
}
```

#### 2.

##### 单调栈解下一个更大的元素1

```
详细描述：给你两个没有重复元素的数组nums1和nums2，其中nums1是nums2 的子集。

请你找出nums1中每个元素在nums2中的下一个比其大的值。

nums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出-1
```

实例：

```
输入:nums1=[4,1,2],nums2=[1,3,4,2].
输出:[-1,3,-1]
解释:
    对于num1中的数字4 ，你无法在第二个数组中找到下一个更大的数字，因此输出-1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3 。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出-1 。
```

##### 思考：

1.每次取num1的元素，找到在nums2的下标位置，然后遍历到nums2的最右侧。这种方法的时间复杂度O(m*n)

2.用map存储num1的每个元素对应的下一个比它大的值，

​	新建一个栈stack，里面存放单调递减的元素(由栈底到栈顶)，对nums2进行遍历

​	若栈为空，则元素直接进栈；

​	若栈不为空，则取栈顶元素和当前遍历到的nums2的元素进行比较，

​															若当前元素大于栈顶元素，则map记录，并且栈顶出栈，继续判断；

​															若当前元素小于等于栈顶元素，则进栈；

​	时间复杂度为O(n)

##### 代码：

```java
public int[] nextGreaterElement(int[] nums1,int[] nums2){
    Map<Integer,Integer> map=new HashMap<>();
    Stack<Integer> stack=new Stack<>();
    for(int num:nums2){
        while(!stack.isEmpty()&&stack.peek()<num){
            map.put(stack.pop(),num);
        }
        stack.push(num);
     }
   	int[] res=new int[nums1.length];
    for(int i=0;i<nums1.length;i++){
        res[i]=map.getOrDefault(nums1[i],-1);
    }
    return res;
}
```

#### 3.

##### 单调栈解下一个更大元素2

给定一个**循环数组**（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字x的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1。

如：

```java
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```



##### 思考：

此题和上题差不多，首尾相接的数组我们可以直接将原数组放长两倍，遍历即可

并且此题没说元素不可以重复，所以map中不可存储数值，存放下标最好，所以stack中也存放下标

##### 代码：

```java
public int[] nextGreaterElement(int[] nums){
    int len=nums.length;
    Stack<Integer> stack=new Stack<>();
    Map<Integer,Integer> map=new HashMap<>();
    for(int i=0;i<len*2;i++){
        //栈为空 当前元素进栈
        //栈顶元素小于当前元素 栈顶出栈 继续比较 直到当前元素小于等于栈顶元素 进栈
        int index=i%len;
        while(!stack.isEmpty()&&nums[stack.peek()]<nums[index]){            
            map.put(stack.pop(),nums[index]);
        }
        stack.push(index);
        
    }
    int[] result=new int[len];
        for(int i=0;i<len;i++){
            result[i]=map.getOrDefault(i,-1);
        }
        return result;
}
```

#### 4.

##### 链表中的下一个更大节点